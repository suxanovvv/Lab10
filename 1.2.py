#2. Сформувати функцію для обчислення цифрового кореню натурального числа.
#Цифровий корінь отримується наступним чином: необхідно скласти всі цифри заданого
#числа, потім скласти всі цифри знайденої суми і повторювати процес до тих пір, поки
#сума не буде дорівнювати однозначному числу, що і буде цифровим коренем заданого
#числа.

import timeit

#Ітераційний розв'зок задачі.
def digit_sqrt(n):
    digit=0
    count=0
    for i in range(len(n)):
        digit+=int(n[i-1])
    if int(digit)>9:
        digit=str(digit)
        for j in range(len(digit)):
            count+=int(digit[j-1])
        return count
    else:
        return digit


x=input('Введіть число, цифровий корінь якого потрібно знайти: ')
print("Ітераційний розв'язок:")
print(digit_sqrt(x))
t = timeit.timeit('"-".join(str(n) for n in range(100))', number=10000)
print("Час виконання ітераційного розв'язку: ", t)
print()


#Рекурсивний розв'зок задачі.
def Summa(n):
    if n<10:
        return n
    else:
        return n%10+Summa(n//10)

def Digital_sqrt_rec(n):
    if n<10:
        return n
    else:
        return Digital_sqrt_rec(Summa(n)) 

y=int(input('Знову введіть число, цифровий корінь якого потрібно знайти: '))
print("Рекурсивний розв'язок:")
print(Digital_sqrt_rec(y))
v = timeit.timeit('"-".join(str(n) for n in range(100))', number=10000)
print("Час виконання рекурсивного розв'язку: ", v)

#У даному випадку рекурсивний розв'язок кращий і потужніший, аніж ітераційний.
#Хоч і рекурсивний розв'зок задачі і займає більше часу при великих значеннях,
#але у ньому прийнаймні відбувається менше порівнянь, аніж у ітераційному.






